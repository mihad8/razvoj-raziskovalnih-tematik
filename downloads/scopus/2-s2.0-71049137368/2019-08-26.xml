<abstracts-retrieval-response xmlns="http://www.elsevier.com/xml/svapi/abstract/dtd" xmlns:dn="http://www.elsevier.com/xml/svapi/abstract/dtd" xmlns:ait="http://www.elsevier.com/xml/ani/ait" xmlns:ce="http://www.elsevier.com/xml/ani/common" xmlns:cto="http://www.elsevier.com/xml/cto/dtd" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/" xmlns:xocs="http://www.elsevier.com/xml/xocs/dtd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><coredata><prism:url>https://api.elsevier.com/content/abstract/scopus_id/71049137368</prism:url><dc:identifier>SCOPUS_ID:71049137368</dc:identifier><eid>2-s2.0-71049137368</eid><prism:doi>10.1007/3-540-45678-3_51</prism:doi><dc:title>Multiprocess time queue</dc:title><prism:aggregationType>Book Series</prism:aggregationType><srctype>k</srctype><subtype>cp</subtype><subtypeDescription>Conference Paper</subtypeDescription><citedby-count>0</citedby-count><prism:publicationName>Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)</prism:publicationName><source-id>25674</source-id><prism:isbn>3540429859</prism:isbn><prism:isbn>9783540429852</prism:isbn><prism:issn>03029743 16113349</prism:issn><prism:volume>2223 LNCS</prism:volume><prism:startingPage>599</prism:startingPage><prism:endingPage>609</prism:endingPage><prism:pageRange>599-609</prism:pageRange><prism:coverDate>2001-12-01</prism:coverDate><openaccess>0</openaccess><openaccessFlag>false</openaccessFlag><dc:creator><author seq="1" auid="6603461888"><ce:initials>A.</ce:initials><ce:indexed-name>Brodnik A.</ce:indexed-name><ce:surname>Brodnik</ce:surname><ce:given-name>Andrej</ce:given-name><preferred-name><ce:initials>A.</ce:initials><ce:indexed-name>Brodnik A.</ce:indexed-name><ce:surname>Brodnik</ce:surname><ce:given-name>Andrej</ce:given-name></preferred-name><author-url>https://api.elsevier.com/content/author/author_id/6603461888</author-url><affiliation id="60007183" href="https://api.elsevier.com/content/affiliation/affiliation_id/60007183"/><affiliation id="60005909" href="https://api.elsevier.com/content/affiliation/affiliation_id/60005909"/></author></dc:creator><dc:description><abstract xmlns="" original="y" xml:lang="eng"><ce:para>We show how to implement a bounded time queue for two dierent processes. The time queue is a variant of a priority queue with elements from a discrete universe. The bounded time queue has elements from a discrete bounded universe. One process has time constraints and may only spend constant worst case time on each operation while the other process may spend more time. The time constrained process only has to be able to perform some of the time queue operations while the other process has to be able to perform all operations.We show how to do a deamortization of the deleteMin cost and to provide mutual exclusion for the parts of the data structure that both processes maintain. © 2001 Springer Berlin Heidelberg.</ce:para></abstract></dc:description><link href="https://api.elsevier.com/content/abstract/scopus_id/71049137368" rel="self"/><link href="https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&amp;scp=71049137368&amp;origin=inward" rel="scopus"/><link href="https://www.scopus.com/inward/citedby.uri?partnerID=HzOxMe3b&amp;scp=71049137368&amp;origin=inward" rel="scopus-citedby"/></coredata><affiliation id="60007183" href="https://api.elsevier.com/content/affiliation/affiliation_id/60007183"><affilname>Luleå tekniska Universitet</affilname><affiliation-city>Lulea</affiliation-city><affiliation-country>Sweden</affiliation-country></affiliation><affiliation id="60005909" href="https://api.elsevier.com/content/affiliation/affiliation_id/60005909"><affilname>Institute of Mathematics, Physics and Mechanics Ljubljana</affilname><affiliation-city>Ljubljana</affiliation-city><affiliation-country>Slovenia</affiliation-country></affiliation><authors><author seq="1" auid="6603461888"><ce:initials>A.</ce:initials><ce:indexed-name>Brodnik A.</ce:indexed-name><ce:surname>Brodnik</ce:surname><ce:given-name>Andrej</ce:given-name><preferred-name><ce:initials>A.</ce:initials><ce:indexed-name>Brodnik A.</ce:indexed-name><ce:surname>Brodnik</ce:surname><ce:given-name>Andrej</ce:given-name></preferred-name><author-url>https://api.elsevier.com/content/author/author_id/6603461888</author-url><affiliation id="60007183" href="https://api.elsevier.com/content/affiliation/affiliation_id/60007183"/><affiliation id="60005909" href="https://api.elsevier.com/content/affiliation/affiliation_id/60005909"/></author><author seq="2" auid="36160344600"><ce:initials>J.</ce:initials><ce:indexed-name>Karlsson J.</ce:indexed-name><ce:surname>Karlsson</ce:surname><ce:given-name>Johan</ce:given-name><preferred-name><ce:initials>J.</ce:initials><ce:indexed-name>Karlsson J.</ce:indexed-name><ce:surname>Karlsson</ce:surname><ce:given-name>Johan</ce:given-name></preferred-name><author-url>https://api.elsevier.com/content/author/author_id/36160344600</author-url><affiliation id="60007183" href="https://api.elsevier.com/content/affiliation/affiliation_id/60007183"/></author></authors><language xml:lang="eng"/><authkeywords/><idxterms><mainterm weight="a" candidate="n">Constrained process</mainterm><mainterm weight="a" candidate="n">Mutual exclusions</mainterm><mainterm weight="a" candidate="n">Priority queues</mainterm><mainterm weight="a" candidate="n">Time constraints</mainterm><mainterm weight="a" candidate="n">Worst case</mainterm><mainterm weight="b" candidate="n">Constrained process</mainterm><mainterm weight="b" candidate="n">Mutual exclusions</mainterm><mainterm weight="b" candidate="n">Priority queues</mainterm><mainterm weight="b" candidate="n">Time constraints</mainterm></idxterms><subject-areas><subject-area code="2614" abbrev="MATH">Theoretical Computer Science</subject-area><subject-area code="1700" abbrev="COMP">Computer Science (all)</subject-area></subject-areas><item xmlns=""><ait:process-info><ait:date-delivered day="09" month="07" timestamp="2019-07-09T14:48:35.000035-04:00" year="2019"/><ait:date-sort day="01" month="12" year="2001"/><ait:status stage="S300" state="update" type="core"/></ait:process-info><bibrecord><item-info><copyright type="Elsevier">Copyright 2009 Elsevier B.V., All rights reserved.</copyright><itemidlist><ce:doi>10.1007/3-540-45678-3_51</ce:doi><itemid idtype="PUI">355583232</itemid><itemid idtype="CPX">20094712457719</itemid><itemid idtype="SCP">71049137368</itemid><itemid idtype="SGR">71049137368</itemid><itemid idtype="PUIsecondary">607211620</itemid><itemid idtype="CAR-ID">642973027</itemid></itemidlist><history><date-created day="16" month="11" year="2009"/></history><dbcollection>CPX</dbcollection><dbcollection>Scopusbase</dbcollection></item-info><head><citation-info><citation-type code="cp"/><citation-language xml:lang="eng" language="English"/><abstract-language xml:lang="eng" language="English"/></citation-info><citation-title><titletext original="y" xml:lang="eng" language="English">Multiprocess time queue</titletext></citation-title><author-group><author auid="6603461888" seq="1"><ce:initials>A.</ce:initials><ce:indexed-name>Brodnik A.</ce:indexed-name><ce:surname>Brodnik</ce:surname><ce:given-name>Andrej</ce:given-name><preferred-name><ce:initials>A.</ce:initials><ce:indexed-name>Brodnik A.</ce:indexed-name><ce:surname>Brodnik</ce:surname><ce:given-name>Andrej</ce:given-name></preferred-name></author><author auid="36160344600" seq="2"><ce:initials>J.</ce:initials><ce:indexed-name>Karlsson J.</ce:indexed-name><ce:surname>Karlsson</ce:surname><ce:given-name>Johan</ce:given-name><preferred-name><ce:initials>J.</ce:initials><ce:indexed-name>Karlsson J.</ce:indexed-name><ce:surname>Karlsson</ce:surname><ce:given-name>Johan</ce:given-name></preferred-name></author><affiliation afid="60007183" country="swe" dptid="103399659"><organization>Department of Computer Science and Electrical Engineering</organization><organization>Luleå University of Technology</organization><city-group>Luleå</city-group><affiliation-id afid="60007183" dptid="103399659"/><country>Sweden</country></affiliation></author-group><author-group><author auid="6603461888" seq="1"><ce:initials>A.</ce:initials><ce:indexed-name>Brodnik A.</ce:indexed-name><ce:surname>Brodnik</ce:surname><ce:given-name>Andrej</ce:given-name><preferred-name><ce:initials>A.</ce:initials><ce:indexed-name>Brodnik A.</ce:indexed-name><ce:surname>Brodnik</ce:surname><ce:given-name>Andrej</ce:given-name></preferred-name></author><affiliation afid="60005909" country="svn" dptid="103340539"><organization>Department of Theoretical Computer Science</organization><organization>Institute of Mathematics, Physics, and Mechanics</organization><city-group>Ljubljana</city-group><affiliation-id afid="60005909" dptid="103340539"/><country>Slovenia</country></affiliation></author-group><correspondence><person><ce:initials>A.</ce:initials><ce:indexed-name>Brodnik A.</ce:indexed-name><ce:surname>Brodnik</ce:surname></person><affiliation country="swe"><organization>Department of Computer Science and Electrical Engineering</organization><organization>Luleå University of Technology</organization><city-group>Luleå</city-group><country>Sweden</country></affiliation></correspondence><abstracts><abstract original="y" xml:lang="eng"><ce:para>We show how to implement a bounded time queue for two dierent processes. The time queue is a variant of a priority queue with elements from a discrete universe. The bounded time queue has elements from a discrete bounded universe. One process has time constraints and may only spend constant worst case time on each operation while the other process may spend more time. The time constrained process only has to be able to perform some of the time queue operations while the other process has to be able to perform all operations.We show how to do a deamortization of the deleteMin cost and to provide mutual exclusion for the parts of the data structure that both processes maintain. © 2001 Springer Berlin Heidelberg.</ce:para></abstract></abstracts><source country="deu" srcid="25674" type="k"><sourcetitle>Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)</sourcetitle><sourcetitle-abbrev>Lect. Notes Comput. Sci.</sourcetitle-abbrev><issuetitle>Algorithms and Computation - 12th International Symposium, ISAAC 2001, Proceedings</issuetitle><issn type="print">03029743</issn><issn type="electronic">16113349</issn><isbn length="10" level="volume">3540429859</isbn><isbn length="13" level="volume">9783540429852</isbn><volisspag><voliss volume="2223 LNCS"/><pagerange first="599" last="609"/></volisspag><publicationyear first="2001"/><publicationdate><year>2001</year><date-text xfab-added="true">2001</date-text></publicationdate><additional-srcinfo><conferenceinfo><confevent><confname>12th International Symposium on Algorithms and Computation, ISAAC 2001</confname><conflocation country="nzl"><city-group>Christchurch</city-group></conflocation><confdate><startdate day="19" month="12" year="2001"/><enddate day="21" month="12" year="2001"/></confdate><confcode>77680</confcode><confsponsors complete="n"><confsponsor>University of Canterbury</confsponsor><confsponsor>Lincoln University</confsponsor><confsponsor>Allied Telesyn Research, Ltd.</confsponsor><confsponsor>JADE</confsponsor><confsponsor>C-fACS</confsponsor></confsponsors></confevent><confpublication><procpagerange>var.pagings</procpagerange></confpublication></conferenceinfo></additional-srcinfo></source><enhancement><classificationgroup><classifications type="CPXCLASS"><classification> <classification-code>721.1</classification-code> <classification-description>Computer Theory (Includes Formal Logic, Automata Theory, Switching Theory and Programming Theory)</classification-description> </classification><classification> <classification-code>723.2</classification-code> <classification-description>Data Processing</classification-description> </classification><classification> <classification-code>723.3</classification-code> <classification-description>Database Systems</classification-description> </classification><classification> <classification-code>921</classification-code> <classification-description>Applied Mathematics</classification-description> </classification><classification> <classification-code>922.1</classification-code> <classification-description>Probability Theory</classification-description> </classification><classification> <classification-code>723.4</classification-code> <classification-description>Artificial Intelligence</classification-description> </classification></classifications><classifications type="GEOCLASS"><classification> <classification-code>Related Topics</classification-code> </classification></classifications><classifications type="FLXCLASS"><classification> <classification-code>902</classification-code> <classification-description>FLUIDEX; Related Topics</classification-description> </classification></classifications><classifications type="ASJC"><classification>2614</classification><classification>1700</classification></classifications><classifications type="SUBJABBR"><classification>MATH</classification><classification>COMP</classification></classifications></classificationgroup></enhancement></head><tail><bibliography refcount="19"><reference id="1"><ref-info><refd-itemidlist><itemid idtype="SGR">71049151548</itemid></refd-itemidlist><ref-text>Arne Andersson and Mikkel Thorup. Tight(er) worst-case bounds on dynamic searching and priority queues. In Proceedi ngs of the Thirty-Second Annual ACM Symposium on Theory of Computing, pages 335-342, Portland, Oregon, US, May 21-23 2000. ACM Press. 601</ref-text></ref-info><ref-fulltext>Arne Andersson and Mikkel Thorup. Tight(er) worst-case bounds on dynamic searching and priority queues. In Proceedi ngs of the Thirty-Second Annual ACM Symposium on Theory of Computing, pages 335-342, Portland, Oregon, US, May 21-23 2000. ACM Press. 601</ref-fulltext></reference><reference id="2"><ref-info><ref-title><ref-titletext>Worst case constant time priority queue</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">65549083420</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>A.</ce:initials><ce:indexed-name>Brodnik A.</ce:indexed-name><ce:surname>Brodnik</ce:surname></author><author seq="2"><ce:initials>S.</ce:initials><ce:indexed-name>Carlsson S.</ce:indexed-name><ce:surname>Carlsson</ce:surname></author><author seq="3"><ce:initials>J.</ce:initials><ce:indexed-name>Karlsson J.</ce:indexed-name><ce:surname>Karlsson</ce:surname></author><author seq="4"><ce:initials>J.</ce:initials><ce:indexed-name>Ian Munro J.</ce:indexed-name><ce:surname>Ian Munro</ce:surname></author></ref-authors><ref-sourcetitle>Proceedings of the Twelfth Annual ACM-SIAM Symposium on Discrete Algorithms</ref-sourcetitle><ref-publicationyear first="2001"/><ref-volisspag><pages>523-528,601</pages></ref-volisspag><ref-text>Washington, DC, US, 7-9 January</ref-text></ref-info><ref-fulltext>Andrej Brodnik, Svante Carlsson, Johan Karlsson, and J. Ian Munro. Worst case constant time priority queue. In Proceedings of the Twelfth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 523-528, Washington, DC, US, 7-9 January 2001. 601</ref-fulltext></reference><reference id="3"><ref-info><refd-itemidlist><itemid idtype="SGR">71049175306</itemid></refd-itemidlist><ref-text>Randy Brown. Calendar queues: A fast O(1) priority queue implementation for the simulation event set problem. Communications of the ACM, 31(10):1220-1227, October 1988. 599, 601, 602</ref-text></ref-info><ref-fulltext>Randy Brown. Calendar queues: A fast O(1) priority queue implementation for the simulation event set problem. Communications of the ACM, 31(10):1220-1227, October 1988. 599, 601, 602</ref-fulltext></reference><reference id="4"><ref-info><ref-title><ref-titletext>Buckets, heaps, lists, and monotone priority queues</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">0030823087</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>B.V.</ce:initials><ce:indexed-name>Cherkassky B.V.</ce:indexed-name><ce:surname>Cherkassky</ce:surname></author><author seq="2"><ce:initials>A.V.</ce:initials><ce:indexed-name>Goldberg A.V.</ce:indexed-name><ce:surname>Goldberg</ce:surname></author><author seq="3"><ce:initials>C.</ce:initials><ce:indexed-name>Silverstein C.</ce:indexed-name><ce:surname>Silverstein</ce:surname></author></ref-authors><ref-sourcetitle>Proceedi ngs of the Eighth Annual ACM-SIAM Symposium on Discrete Algorithms</ref-sourcetitle><ref-publicationyear first="1997"/><ref-volisspag><pages>83-92,600</pages></ref-volisspag><ref-text>New Orleans, Louisiana, US, 5-7 January</ref-text></ref-info><ref-fulltext>Boris V. Cherkassky, Andrew V. Goldberg, and Craig Silverstein. Buckets, heaps, lists, and monotone priority queues. In Proceedi ngs of the Eighth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 83-92, New Orleans, Louisiana, US, 5-7 January 1997. 600</ref-fulltext></reference><reference id="5"><ref-info><ref-title><ref-titletext>System deadlocks</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">0002996171</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>E.G.</ce:initials><ce:indexed-name>Coffman Jr. E.G.</ce:indexed-name><ce:surname>Coffman Jr.</ce:surname></author><author seq="2"><ce:initials>M.J.</ce:initials><ce:indexed-name>Elphick M.J.</ce:indexed-name><ce:surname>Elphick</ce:surname></author><author seq="3"><ce:initials>A.</ce:initials><ce:indexed-name>Shoshani A.</ce:indexed-name><ce:surname>Shoshani</ce:surname></author></ref-authors><ref-sourcetitle>ACM Computing Surveys</ref-sourcetitle><ref-publicationyear first="1971"/><ref-volisspag><voliss volume="67-78"/><pagerange first="607"/></ref-volisspag><ref-text>32, June</ref-text></ref-info><ref-fulltext>E. G. Coffman, Jr., M. J. Elphick, and A. Shoshani. System deadlocks. ACM Computing Surveys, 3(2):67-78, June 1971. 607</ref-fulltext></reference><reference id="6"><ref-info><ref-title><ref-titletext>Dynamic perfect hashing: Upper and lower bounds</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">85046063373</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>M.</ce:initials><ce:indexed-name>Dietzfelbinger M.</ce:indexed-name><ce:surname>Dietzfelbinger</ce:surname></author><author seq="2"><ce:initials>A.</ce:initials><ce:indexed-name>Karlin A.</ce:indexed-name><ce:surname>Karlin</ce:surname></author><author seq="3"><ce:initials>K.</ce:initials><ce:indexed-name>Mehlhorn K.</ce:indexed-name><ce:surname>Mehlhorn</ce:surname></author><author seq="4"><ce:initials>F.</ce:initials><ce:indexed-name>Meyer auf der Heide F.</ce:indexed-name><ce:surname>Meyer auf der Heide</ce:surname></author><author seq="5"><ce:initials>H.</ce:initials><ce:indexed-name>Rohnert H.</ce:indexed-name><ce:surname>Rohnert</ce:surname></author><author seq="6"><ce:initials>R.E.</ce:initials><ce:indexed-name>Tarjan R.E.</ce:indexed-name><ce:surname>Tarjan</ce:surname></author></ref-authors><ref-sourcetitle>SIAM Journal on Computing</ref-sourcetitle><ref-publicationyear first="1994"/><ref-volisspag><voliss volume="738-791"/><pagerange first="601"/></ref-volisspag><ref-text>234</ref-text></ref-info><ref-fulltext>Martin Dietzfelbinger, Anna Karlin, Kurt Mehlhorn, Friedhelm Meyer auf der Heide, Hans Rohnert, and Robert E. Tarjan. Dynamic perfect hashing: Upper and lower bounds. SIAM Journal on Computing, 23(4):738-791, 1994. 601</ref-fulltext></reference><reference id="7"><ref-info><refd-itemidlist><itemid idtype="SGR">71049155381</itemid></refd-itemidlist><ref-text>K. Bruce Erickson, Richard E. Ladner, and Anthony LaMarca. Optimizing static calendar queues. In 35th Annual Symposium on Foundations of Computer Science (FOCS), pages 732-742. IEEE, 20-22 November 1994. Also published as tech. report TR-94-09-02 ftp://ftp.cs.washington.edu/tr/1994/09/UW-CSE-94-09-02. PS.Z. 602, 603</ref-text></ref-info><ref-fulltext>K. Bruce Erickson, Richard E. Ladner, and Anthony LaMarca. Optimizing static calendar queues. In 35th Annual Symposium on Foundations of Computer Science (FOCS), pages 732-742. IEEE, 20-22 November 1994. Also published as tech. report TR-94-09-02 ftp://ftp.cs.washington.edu/tr/1994/09/UW-CSE-94-09-02. PS.Z. 602, 603</ref-fulltext></reference><reference id="8"><ref-info><refd-itemidlist><itemid idtype="SGR">71049144850</itemid></refd-itemidlist><ref-text>Michael L. Fredman, János Komlós, and Endre Szemerédi. Storing a sparse table with O(1) worst case access time. Journal of the ACM, 31(3):538-544, July 1984. 601</ref-text></ref-info><ref-fulltext>Michael L. Fredman, János Komlós, and Endre Szemerédi. Storing a sparse table with O(1) worst case access time. Journal of the ACM, 31(3):538-544, July 1984. 601</ref-fulltext></reference><reference id="9"><ref-info><refd-itemidlist><itemid idtype="SGR">71049157967</itemid></refd-itemidlist><ref-text>Michael L. Fredman and Michael E. Saks. The cell probe complexity of dynamic data structures. In Proceedings of the Twenty-First Annual ACM Symposium on Theory of Computing, pages 345-354, Seattle, Washington, US, May 14-17 1989. ACM Press. 601</ref-text></ref-info><ref-fulltext>Michael L. Fredman and Michael E. Saks. The cell probe complexity of dynamic data structures. In Proceedings of the Twenty-First Annual ACM Symposium on Theory of Computing, pages 345-354, Seattle, Washington, US, May 14-17 1989. ACM Press. 601</ref-fulltext></reference><reference id="10"><ref-info><ref-title><ref-titletext>An empirical comparison of priority-queue and event-set implementations</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">0022698884</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>D.W.</ce:initials><ce:indexed-name>Jones D.W.</ce:indexed-name><ce:surname>Jones</ce:surname></author></ref-authors><ref-sourcetitle>Communications of the ACM</ref-sourcetitle><ref-publicationyear first="1986"/><ref-volisspag><voliss issue="4" volume="29"/><pages>300-311,601</pages></ref-volisspag><ref-text>April</ref-text></ref-info><ref-fulltext>Douglas W. Jones. An empirical comparison of priority-queue and event-set implementations. Communications of the ACM, 29(4):300-311, April 1986. 601</ref-fulltext></reference><reference id="11"><ref-info><ref-title><ref-titletext>Storage modifications machines</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">0000371259</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>A.</ce:initials><ce:indexed-name>Schonhage A.</ce:indexed-name><ce:surname>Schönhage</ce:surname></author></ref-authors><ref-sourcetitle>SIAM Journal on Computing</ref-sourcetitle><ref-publicationyear first="1980"/><ref-volisspag><voliss volume="490-508"/><pagerange first="601"/></ref-volisspag><ref-text>93, August</ref-text></ref-info><ref-fulltext>Arnold Schönhage. Storage modifications machines. SIAM Journal on Computing, 9(3):490-508, August 1980. 601</ref-fulltext></reference><reference id="12"><ref-info><ref-title><ref-titletext>On RAM priority queues</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">0005483705</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>M.</ce:initials><ce:indexed-name>Thorup M.</ce:indexed-name><ce:surname>Thorup</ce:surname></author></ref-authors><ref-sourcetitle>Proceedings of the Seventh Annual ACM-SIAM Symposium on Discrete Algorithms</ref-sourcetitle><ref-publicationyear first="1996"/><ref-volisspag><voliss issue="603" volume="600"/><pages>59-67,604</pages></ref-volisspag><ref-text>Atlanta, Georgia, US, 28-30 January</ref-text></ref-info><ref-fulltext>Mikkel Thorup. On RAM priority queues. In Proceedings of the Seventh Annual ACM-SIAM Symposium on Discrete Algorithms, pages 59-67, Atlanta, Georgia, US, 28-30 January 1996. 600, 603, 604</ref-fulltext></reference><reference id="13"><ref-info><ref-title><ref-titletext>Preserving order in a forest in less than logarithmic time</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">85059435521</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>P.</ce:initials><ce:indexed-name>van Emde Boas P.</ce:indexed-name><ce:surname>van Emde Boas</ce:surname></author></ref-authors><ref-sourcetitle>16th Symposium on Foundations of Computer Science</ref-sourcetitle><ref-publicationyear first="1975"/><ref-volisspag><pages>75-84,601</pages></ref-volisspag></ref-info><ref-fulltext>P. van Emde Boas. Preserving order in a forest in less than logarithmic time. In 16th Symposium on Foundations of Computer Science, pages 75-84, 1975. 601</ref-fulltext></reference><reference id="14"><ref-info><refd-itemidlist><itemid idtype="SGR">71049166745</itemid></refd-itemidlist><ref-text>P. van Emde Boas. Machine models and simulations. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, A: Algorithms and Complexity, pages 3-66. Elsevier/MIT Press, Amsterdam, 1990. 601</ref-text></ref-info><ref-fulltext>P. van Emde Boas. Machine models and simulations. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science, volume A: Algorithms and Complexity, pages 3-66. Elsevier/MIT Press, Amsterdam, 1990. 601</ref-fulltext></reference><reference id="15"><ref-info><ref-title><ref-titletext>Design and implementation of an efficient priority queue</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">34250391491</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>P.</ce:initials><ce:indexed-name>van Emde Boas P.</ce:indexed-name><ce:surname>van Emde Boas</ce:surname></author><author seq="2"><ce:initials>R.</ce:initials><ce:indexed-name>Kaas R.</ce:indexed-name><ce:surname>Kaas</ce:surname></author><author seq="3"><ce:initials>E.</ce:initials><ce:indexed-name>Zijlstra E.</ce:indexed-name><ce:surname>Zijlstra</ce:surname></author></ref-authors><ref-sourcetitle>Mathematical Systems Theory</ref-sourcetitle><ref-publicationyear first="1977"/><ref-volisspag><voliss issue="99-127" volume="10"/><pagerange first="601"/></ref-volisspag></ref-info><ref-fulltext>P. van Emde Boas, R. Kaas, and E. Zijlstra. Design and implementation of an efficient priority queue. Mathematical Systems Theory, 10:99-127, 1977. 601</ref-fulltext></reference><reference id="16"><ref-info><refd-itemidlist><itemid idtype="SGR">71049114271</itemid></refd-itemidlist><ref-text>George Varghese and Anthony Lauck. Hashed and hierarchical timing wheels: Efficient data structure for implementing a timer facility. IEEE/ACM Transaction on Networking, 5(6):824-834, December 1997. 603, 608</ref-text></ref-info><ref-fulltext>George Varghese and Anthony Lauck. Hashed and hierarchical timing wheels: Efficient data structure for implementing a timer facility. IEEE/ACM Transaction on Networking, 5(6):824-834, December 1997. 603, 608</ref-fulltext></reference><reference id="17"><ref-info><refd-itemidlist><itemid idtype="SGR">71049140439</itemid></refd-itemidlist><ref-text>Dan E. Willard. Log-logarithmic worst-case range queries are possible in space θ(N). Information Processing Letters, 17(2):81-84, 24 August 1983. 601</ref-text></ref-info><ref-fulltext>Dan E. Willard. Log-logarithmic worst-case range queries are possible in space θ(N). Information Processing Letters, 17(2):81-84, 24 August 1983. 601</ref-fulltext></reference><reference id="18"><ref-info><ref-title><ref-titletext>Algorithm 232: Heapsort</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">0000890375</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>J.W.J.</ce:initials><ce:indexed-name>Williams J.W.J.</ce:indexed-name><ce:surname>Williams</ce:surname></author></ref-authors><ref-sourcetitle>Communications of the ACM</ref-sourcetitle><ref-publicationyear first="1964"/><ref-volisspag><voliss issue="347-348" volume="7"/><pagerange first="601"/></ref-volisspag></ref-info><ref-fulltext>J. W. J. Williams. Algorithm 232: Heapsort. Communications of the ACM, 7:347-348, 1964. 601</ref-fulltext></reference><reference id="19"><ref-info><refd-itemidlist><itemid idtype="SGR">71049147941</itemid></refd-itemidlist><ref-text>Andrew Chi-Chih Yao. Should tables be sorted? Journal of the ACM, 28(3):614-628, July 1981. 601</ref-text></ref-info><ref-fulltext>Andrew Chi-Chih Yao. Should tables be sorted? Journal of the ACM, 28(3):614-628, July 1981. 601</ref-fulltext></reference></bibliography></tail></bibrecord></item></abstracts-retrieval-response>