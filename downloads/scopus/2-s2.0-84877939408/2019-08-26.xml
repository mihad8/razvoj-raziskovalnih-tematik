<abstracts-retrieval-response xmlns="http://www.elsevier.com/xml/svapi/abstract/dtd" xmlns:dn="http://www.elsevier.com/xml/svapi/abstract/dtd" xmlns:ait="http://www.elsevier.com/xml/ani/ait" xmlns:ce="http://www.elsevier.com/xml/ani/common" xmlns:cto="http://www.elsevier.com/xml/cto/dtd" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/" xmlns:xocs="http://www.elsevier.com/xml/xocs/dtd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><coredata><prism:url>https://api.elsevier.com/content/abstract/scopus_id/84877939408</prism:url><dc:identifier>SCOPUS_ID:84877939408</dc:identifier><eid>2-s2.0-84877939408</eid><prism:doi>10.1145/2480362.2480682</prism:doi><dc:title>LLLR parsing</dc:title><prism:aggregationType>Conference Proceeding</prism:aggregationType><srctype>p</srctype><subtype>cp</subtype><subtypeDescription>Conference Paper</subtypeDescription><citedby-count>2</citedby-count><prism:publicationName>Proceedings of the ACM Symposium on Applied Computing</prism:publicationName><source-id>89358</source-id><prism:isbn>9781450316569</prism:isbn><prism:startingPage>1698</prism:startingPage><prism:endingPage>1699</prism:endingPage><prism:pageRange>1698-1699</prism:pageRange><prism:coverDate>2013-05-27</prism:coverDate><openaccess>0</openaccess><openaccessFlag>false</openaccessFlag><dc:creator><author seq="1" auid="6507603461"><ce:initials>B.</ce:initials><ce:indexed-name>Slivnik B.</ce:indexed-name><ce:surname>Slivnik</ce:surname><ce:given-name>Boštjan</ce:given-name><preferred-name><ce:initials>B.</ce:initials><ce:indexed-name>Slivnik B.</ce:indexed-name><ce:surname>Slivnik</ce:surname><ce:given-name>Boštjan</ce:given-name></preferred-name><author-url>https://api.elsevier.com/content/author/author_id/6507603461</author-url><affiliation id="60031106" href="https://api.elsevier.com/content/affiliation/affiliation_id/60031106"/></author></dc:creator><dc:description><abstract xmlns="" original="y" xml:lang="eng">
<ce:para>The idea of an LLLR parsing is presented. An LLLR(k) parser can be constructed for any LR(k) grammar but it produces the left parse of the input string in linear time (in respect to the length of the derivation) without backtracking. If used as a basis for a syntax-directed translation, it triggers semantic actions using the top-down strategy just like the canonical LL(k) parser. Hence, from a compiler writer's point of view, it acts as an LL(k) parser. The backbone of the LLLR(k) parser is the LL(k) parser which triggers the embedded left LR(k) parser whenever an LL(k) conflict appears during parsing. Once the embedded LR(k) parser resolves the conflict, it passes the control back to the backbone LL(k) parser together with the left parse of the part of the input string scanned by the embedded LR parser, and LL parsing continues. Hence, LLLR parsing is similar to LL(<sup>*</sup>) parsing except (a) it uses LR(k) parsers instead of finite automata to resolve the LL(k) conflicts and (b) that it does not need to use backtracking. An LLLR(k) parser is the most appropriate for grammars where the LL(k) conflicting nonterminals appear relatively close to the leaves of the derivation trees. Copyright 2013 ACM.</ce:para>
</abstract></dc:description><link href="https://api.elsevier.com/content/abstract/scopus_id/84877939408" rel="self"/><link href="https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&amp;scp=84877939408&amp;origin=inward" rel="scopus"/><link href="https://www.scopus.com/inward/citedby.uri?partnerID=HzOxMe3b&amp;scp=84877939408&amp;origin=inward" rel="scopus-citedby"/></coredata><affiliation id="60031106" href="https://api.elsevier.com/content/affiliation/affiliation_id/60031106"><affilname>University of Ljubljana</affilname><affiliation-city>Ljubljana</affiliation-city><affiliation-country>Slovenia</affiliation-country></affiliation><authors><author seq="1" auid="6507603461"><ce:initials>B.</ce:initials><ce:indexed-name>Slivnik B.</ce:indexed-name><ce:surname>Slivnik</ce:surname><ce:given-name>Boštjan</ce:given-name><preferred-name><ce:initials>B.</ce:initials><ce:indexed-name>Slivnik B.</ce:indexed-name><ce:surname>Slivnik</ce:surname><ce:given-name>Boštjan</ce:given-name></preferred-name><author-url>https://api.elsevier.com/content/author/author_id/6507603461</author-url><affiliation id="60031106" href="https://api.elsevier.com/content/affiliation/affiliation_id/60031106"/></author></authors><language xml:lang="eng"/><authkeywords><author-keyword>Left parse</author-keyword><author-keyword>LL parsing</author-keyword><author-keyword>LR languages</author-keyword></authkeywords><idxterms><mainterm weight="a" candidate="n">Compiler writers</mainterm><mainterm weight="a" candidate="n">Input string</mainterm><mainterm weight="a" candidate="n">Left parse</mainterm><mainterm weight="a" candidate="n">Linear time</mainterm><mainterm weight="a" candidate="n">LL parsing</mainterm><mainterm weight="a" candidate="n">Point of views</mainterm><mainterm weight="a" candidate="n">Semantic action</mainterm><mainterm weight="a" candidate="n">Syntax-directed translations</mainterm></idxterms><subject-areas><subject-area code="1712" abbrev="COMP">Software</subject-area></subject-areas><item xmlns=""><ait:process-info><ait:date-delivered day="13" month="06" timestamp="2013-06-13T09:57:52.000052+01:00" year="2013"/><ait:date-sort day="27" month="05" year="2013"/><ait:status stage="S300" state="update" type="core"/></ait:process-info><bibrecord><item-info><copyright type="Elsevier">Copyright 2013 Elsevier B.V., All rights reserved.</copyright><itemidlist>
<ce:doi>10.1145/2480362.2480682</ce:doi>
<itemid idtype="PUI">368950299</itemid>
<itemid idtype="CPX">20132216366846</itemid>
<itemid idtype="SCP">84877939408</itemid>
<itemid idtype="SGR">84877939408</itemid>
</itemidlist><history>
<date-created day="27" month="05" year="2013"/>
</history><dbcollection>CPX</dbcollection><dbcollection>Scopusbase</dbcollection></item-info><head><citation-info><citation-type code="cp"/><citation-language xml:lang="eng" language="English"/><abstract-language xml:lang="eng" language="English"/><author-keywords>
<author-keyword>Left parse</author-keyword>
<author-keyword>LL parsing</author-keyword>
<author-keyword>LR languages</author-keyword>
</author-keywords></citation-info><citation-title><titletext original="y" xml:lang="eng" language="English">LLLR parsing</titletext></citation-title><author-group><author auid="6507603461" seq="1"><ce:initials>B.</ce:initials><ce:indexed-name>Slivnik B.</ce:indexed-name><ce:surname>Slivnik</ce:surname><ce:given-name>Boštjan</ce:given-name><preferred-name>
<ce:initials>B.</ce:initials>
<ce:indexed-name>Slivnik B.</ce:indexed-name>
<ce:surname>Slivnik</ce:surname>
<ce:given-name>Boštjan</ce:given-name>
</preferred-name></author><affiliation afid="60031106" country="svn"><organization>Faculty of Computer and Information Science</organization><organization>University of Ljubljana</organization><address-part>Tržaška Ulica 25</address-part><city-group>1000 Ljubljana</city-group><country>Slovenia</country></affiliation></author-group><correspondence><person>
<ce:initials>B.</ce:initials>
<ce:indexed-name>Slivnik B.</ce:indexed-name>
<ce:surname>Slivnik</ce:surname>
</person><affiliation country="svn"><organization>Faculty of Computer and Information Science</organization><organization>University of Ljubljana</organization><address-part>Tržaška Ulica 25</address-part><city-group>1000 Ljubljana</city-group><country>Slovenia</country></affiliation></correspondence><abstracts><abstract original="y" xml:lang="eng">
<ce:para>The idea of an LLLR parsing is presented. An LLLR(k) parser can be constructed for any LR(k) grammar but it produces the left parse of the input string in linear time (in respect to the length of the derivation) without backtracking. If used as a basis for a syntax-directed translation, it triggers semantic actions using the top-down strategy just like the canonical LL(k) parser. Hence, from a compiler writer's point of view, it acts as an LL(k) parser. The backbone of the LLLR(k) parser is the LL(k) parser which triggers the embedded left LR(k) parser whenever an LL(k) conflict appears during parsing. Once the embedded LR(k) parser resolves the conflict, it passes the control back to the backbone LL(k) parser together with the left parse of the part of the input string scanned by the embedded LR parser, and LL parsing continues. Hence, LLLR parsing is similar to LL(<sup>*</sup>) parsing except (a) it uses LR(k) parsers instead of finite automata to resolve the LL(k) conflicts and (b) that it does not need to use backtracking. An LLLR(k) parser is the most appropriate for grammars where the LL(k) conflicting nonterminals appear relatively close to the leaves of the derivation trees. Copyright 2013 ACM.</ce:para>
</abstract></abstracts><source country="usa" srcid="89358" type="p"><sourcetitle>Proceedings of the ACM Symposium on Applied Computing</sourcetitle><sourcetitle-abbrev>Proc ACM Symp Appl Computing</sourcetitle-abbrev><issuetitle>28th Annual ACM Symposium on Applied Computing, SAC 2013</issuetitle><isbn length="13" level="volume">9781450316569</isbn><volisspag>
<pagerange first="1698" last="1699"/>
</volisspag><publicationyear first="2013"/><publicationdate>
<year>2013</year>
<date-text xfab-added="true">2013</date-text></publicationdate><additional-srcinfo>
<conferenceinfo>
<confevent>
<confname>28th Annual ACM Symposium on Applied Computing, SAC 2013</confname>
<conflocation country="prt">
<city-group>Coimbra</city-group>
</conflocation>
<confdate>
<startdate day="18" month="03" year="2013"/>
<enddate day="22" month="03" year="2013"/>
</confdate>
<confcode>96995</confcode>
<confsponsors complete="y">
<confsponsor>ACM Special Interest Group on Applied Computing (SIGAPP)</confsponsor>
<confsponsor>ISEC Engenharia</confsponsor>
<confsponsor>Politecnico de Coimbra</confsponsor>
<confsponsor>Caixa Geral de Depositos</confsponsor>
<confsponsor>Institute of Systems and Robotics (ISR), University of Coimbra</confsponsor>
</confsponsors>
</confevent>
<confpublication>
<procpagerange>var.pagings</procpagerange>
</confpublication>
</conferenceinfo>
</additional-srcinfo></source><enhancement><classificationgroup>
<classifications type="ASJC">
<classification>1712</classification>
</classifications><classifications type="SUBJABBR"><classification>COMP</classification></classifications>
<classifications type="CPXCLASS">
<classification> <classification-code>721.1</classification-code> <classification-description>Computer Theory (Includes Formal Logic, Automata Theory, Switching Theory and Programming Theory)</classification-description> </classification>
<classification> <classification-code>903.2</classification-code> <classification-description>Information Dissemination</classification-description> </classification>
</classifications>
<classifications type="GEOCLASS">
<classification> <classification-code>Related Topics</classification-code> </classification>
</classifications>
</classificationgroup></enhancement></head><tail><bibliography refcount="7">
<reference id="1">
<ref-info>
<ref-title>
<ref-titletext>Recursive ascent-descent parsing</ref-titletext>
</ref-title>
<refd-itemidlist>
<itemid idtype="SGR">84877962801</itemid>
</refd-itemidlist>
<ref-authors>
<author seq="1">
<ce:initials>R.N.</ce:initials>
<ce:indexed-name>Horspool R.N.</ce:indexed-name>
<ce:surname>Horspool</ce:surname>
</author>
</ref-authors>
<ref-sourcetitle>Journal of Computer Languages</ref-sourcetitle>
<ref-publicationyear first="1993"/>
<ref-volisspag>
<voliss issue="1" volume="18"/>
<pagerange first="1" last="16"/>
</ref-volisspag>
</ref-info>
<ref-fulltext>R. N. Horspool. Recursive ascent-descent parsing. Journal of Computer Languages, 18(1): 1-16, 1993.</ref-fulltext>
</reference>
<reference id="2">
<ref-info>
<ref-title>
<ref-titletext>LL(<sup>*</sup>): The foundation of the ANTLR parser generator</ref-titletext>
</ref-title>
<refd-itemidlist>
<itemid idtype="SGR">79959911655</itemid>
</refd-itemidlist>
<ref-authors>
<author seq="1">
<ce:initials>T.</ce:initials>
<ce:indexed-name>Parr T.</ce:indexed-name>
<ce:surname>Parr</ce:surname>
</author>
<author seq="2">
<ce:initials>K.</ce:initials>
<ce:indexed-name>Fischer K.</ce:indexed-name>
<ce:surname>Fischer</ce:surname>
</author>
</ref-authors>
<ref-sourcetitle>ACM SIGPLAN Notices - PLDI'10</ref-sourcetitle>
<ref-publicationyear first="2011"/>
<ref-volisspag>
<voliss issue="6" volume="46"/>
<pagerange first="425" last="436"/>
</ref-volisspag>
</ref-info>
<ref-fulltext>T. Parr and K. Fischer. LL(<sup>*</sup>): The foundation of the ANTLR parser generator. ACM SIGPLAN Notices - PLDI'10, 46(6): 425-436, 2011.</ref-fulltext>
</reference>
<reference id="3">
<ref-info>
<refd-itemidlist>
<itemid idtype="SGR">0000896497</itemid>
</refd-itemidlist>
<ref-authors>
<author seq="1">
<ce:initials>P.</ce:initials>
<ce:indexed-name>Purdom P.</ce:indexed-name>
<ce:surname>Purdom</ce:surname>
</author>
<author seq="2">
<ce:initials>A.C.</ce:initials>
<ce:indexed-name>Brown A.C.</ce:indexed-name>
<ce:surname>Brown</ce:surname>
</author>
</ref-authors>
<ref-sourcetitle>Semantic Routines and LR(k) Parsers. Acta Informatica</ref-sourcetitle>
<ref-publicationyear first="1980"/>
<ref-volisspag>
<voliss issue="4" volume="14"/>
<pagerange first="299" last="315"/>
</ref-volisspag>
</ref-info>
<ref-fulltext>P. Purdom and C. A. Brown. Semantic routines and LR(k) parsers. Acta Informatica, 14(4): 299-315, 1980.</ref-fulltext>
</reference>
<reference id="4">
<ref-info>
<ref-title>
<ref-titletext>Producing a top-down parse order with bottom-up parsing</ref-titletext>
</ref-title>
<refd-itemidlist>
<itemid idtype="SGR">0029327943</itemid>
</refd-itemidlist>
<ref-authors>
<author seq="1">
<ce:initials>J.P.</ce:initials>
<ce:indexed-name>Schmeiser J.P.</ce:indexed-name>
<ce:surname>Schmeiser</ce:surname>
</author>
<author seq="2">
<ce:initials>D.T.</ce:initials>
<ce:indexed-name>Barnard D.T.</ce:indexed-name>
<ce:surname>Barnard</ce:surname>
</author>
</ref-authors>
<ref-sourcetitle>Information Processing Letters</ref-sourcetitle>
<ref-publicationyear first="1995"/>
<ref-volisspag>
<voliss issue="6" volume="54"/>
<pagerange first="323" last="326"/>
</ref-volisspag>
</ref-info>
<ref-fulltext>J. P. Schmeiser and D. T. Barnard. Producing a top-down parse order with bottom-up parsing. Information Processing Letters, 54(6): 323-326, 1995.</ref-fulltext>
</reference>
<reference id="5">
<ref-info>
<ref-title>
<ref-titletext>GLL parsing</ref-titletext>
</ref-title>
<refd-itemidlist>
<itemid idtype="SGR">77956404406</itemid>
</refd-itemidlist>
<ref-authors>
<author seq="1">
<ce:initials>E.</ce:initials>
<ce:indexed-name>Scott E.</ce:indexed-name>
<ce:surname>Scott</ce:surname>
</author>
<author seq="2">
<ce:initials>A.</ce:initials>
<ce:indexed-name>Johnstone A.</ce:indexed-name>
<ce:surname>Johnstone</ce:surname>
</author>
</ref-authors>
<ref-sourcetitle>Electronic Notes in Theoretical Computer Science</ref-sourcetitle>
<ref-publicationyear first="2010"/>
<ref-volisspag>
<voliss issue="7" volume="253"/>
<pagerange first="177" last="189"/>
</ref-volisspag>
</ref-info>
<ref-fulltext>E. Scott and A. Johnstone. GLL parsing. Electronic Notes in Theoretical Computer Science, 253(7): 177-189, 2010.</ref-fulltext>
</reference>
<reference id="6">
<ref-info>
<ref-title>
<ref-titletext>LL conflict resolution using the embedded left LR parser</ref-titletext>
</ref-title>
<refd-itemidlist>
<itemid idtype="SGR">84867478023</itemid>
</refd-itemidlist>
<ref-authors>
<author seq="1">
<ce:initials>B.</ce:initials>
<ce:indexed-name>Slivnik B.</ce:indexed-name>
<ce:surname>Slivnik</ce:surname>
</author>
</ref-authors>
<ref-sourcetitle>Computer Science and Information Systems</ref-sourcetitle>
<ref-publicationyear first="2012"/>
<ref-volisspag>
<voliss issue="3" volume="9"/>
<pagerange first="1105" last="1124"/>
</ref-volisspag>
</ref-info>
<ref-fulltext>B. Slivnik. LL conflict resolution using the embedded left LR parser. Computer Science and Information Systems, 9(3): 1105-1124, 2012.</ref-fulltext>
</reference>
<reference id="7">
<ref-info>
<ref-title>
<ref-titletext>Producing the left parse during bottom-up parsing</ref-titletext>
</ref-title>
<refd-itemidlist>
<itemid idtype="SGR">27644524569</itemid>
</refd-itemidlist>
<ref-authors>
<author seq="1">
<ce:initials>B.</ce:initials>
<ce:indexed-name>Slivnik B.</ce:indexed-name>
<ce:surname>Slivnik</ce:surname>
</author>
<author seq="2">
<ce:initials>B.</ce:initials>
<ce:indexed-name>Vilfan B.</ce:indexed-name>
<ce:surname>Vilfan</ce:surname>
</author>
</ref-authors>
<ref-sourcetitle>Information Processing Letters</ref-sourcetitle>
<ref-publicationyear first="2005"/>
<ref-volisspag>
<voliss issue="6" volume="96"/>
<pagerange first="220" last="224"/>
</ref-volisspag>
</ref-info>
<ref-fulltext>B. Slivnik and B. Vilfan. Producing the left parse during bottom-up parsing. Information Processing Letters, 96(6): 220-224, 2005.</ref-fulltext>
</reference>
</bibliography></tail></bibrecord></item></abstracts-retrieval-response>