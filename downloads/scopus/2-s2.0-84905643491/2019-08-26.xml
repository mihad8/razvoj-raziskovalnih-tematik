<abstracts-retrieval-response xmlns="http://www.elsevier.com/xml/svapi/abstract/dtd" xmlns:dn="http://www.elsevier.com/xml/svapi/abstract/dtd" xmlns:ait="http://www.elsevier.com/xml/ani/ait" xmlns:ce="http://www.elsevier.com/xml/ani/common" xmlns:cto="http://www.elsevier.com/xml/cto/dtd" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/" xmlns:xocs="http://www.elsevier.com/xml/xocs/dtd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><coredata><prism:url>https://api.elsevier.com/content/abstract/scopus_id/84905643491</prism:url><dc:identifier>SCOPUS_ID:84905643491</dc:identifier><eid>2-s2.0-84905643491</eid><prism:doi>10.1145/2554850.2555129</prism:doi><dc:title>Linter - A tool for finding bugs and potential problems in Scala code</dc:title><prism:aggregationType>Conference Proceeding</prism:aggregationType><srctype>p</srctype><subtype>cp</subtype><subtypeDescription>Conference Paper</subtypeDescription><citedby-count>1</citedby-count><prism:publicationName>Proceedings of the ACM Symposium on Applied Computing</prism:publicationName><dc:publisher>Association for Computing Machineryacmhelpacm.org</dc:publisher><source-id>89358</source-id><prism:isbn>9781450324694</prism:isbn><prism:startingPage>1615</prism:startingPage><prism:endingPage>1616</prism:endingPage><prism:pageRange>1615-1616</prism:pageRange><prism:coverDate>2014-01-01</prism:coverDate><openaccess>0</openaccess><openaccessFlag>false</openaccessFlag><dc:creator><author seq="1" auid="6602764771"><ce:initials>M.</ce:initials><ce:indexed-name>Potocnik M.</ce:indexed-name><ce:surname>Potocnik</ce:surname><ce:given-name>Matic</ce:given-name><preferred-name><ce:initials>M.</ce:initials><ce:indexed-name>Potocnik M.</ce:indexed-name><ce:surname>Potocnik</ce:surname><ce:given-name>Matic</ce:given-name></preferred-name><author-url>https://api.elsevier.com/content/author/author_id/6602764771</author-url><affiliation id="60031106" href="https://api.elsevier.com/content/affiliation/affiliation_id/60031106"/></author></dc:creator><dc:description><abstract xmlns="" original="y" xml:lang="eng"><ce:para>Linter is a static analysis tool for Scala. To check for possible bugs, inefficient code, and coding style problems it combines simple pattern matching used in many similar static analysis tools for other programming languages with abstract interpretation on some builtin types like integers and strings. Taking advantage of the Scala compiler plugin interface it relies on the Scala compiler (a) to parse the source code and (b) to provide the abstract syntax tree with all needed information. This paper provides an overview of Linter and its implementation. Using a case study the performance of Linter is evaluated in terms of time consumption and code issues detected. Copyright 2014 ACM.</ce:para></abstract></dc:description><link href="https://api.elsevier.com/content/abstract/scopus_id/84905643491" rel="self"/><link href="https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&amp;scp=84905643491&amp;origin=inward" rel="scopus"/><link href="https://www.scopus.com/inward/citedby.uri?partnerID=HzOxMe3b&amp;scp=84905643491&amp;origin=inward" rel="scopus-citedby"/></coredata><affiliation id="60031106" href="https://api.elsevier.com/content/affiliation/affiliation_id/60031106"><affilname>University of Ljubljana</affilname><affiliation-city>Ljubljana</affiliation-city><affiliation-country>Slovenia</affiliation-country></affiliation><authors><author seq="1" auid="6602764771"><ce:initials>M.</ce:initials><ce:indexed-name>Potocnik M.</ce:indexed-name><ce:surname>Potocnik</ce:surname><ce:given-name>Matic</ce:given-name><preferred-name><ce:initials>M.</ce:initials><ce:indexed-name>Potocnik M.</ce:indexed-name><ce:surname>Potocnik</ce:surname><ce:given-name>Matic</ce:given-name></preferred-name><author-url>https://api.elsevier.com/content/author/author_id/6602764771</author-url><affiliation id="60031106" href="https://api.elsevier.com/content/affiliation/affiliation_id/60031106"/></author><author seq="2" auid="8911840700"><ce:initials>U.</ce:initials><ce:indexed-name>Cibej U.</ce:indexed-name><ce:surname>Čibej</ce:surname><ce:given-name>Uroš</ce:given-name><preferred-name><ce:initials>U.</ce:initials><ce:indexed-name>Čibej U.</ce:indexed-name><ce:surname>Čibej</ce:surname><ce:given-name>Uroš</ce:given-name></preferred-name><author-url>https://api.elsevier.com/content/author/author_id/8911840700</author-url><affiliation id="60031106" href="https://api.elsevier.com/content/affiliation/affiliation_id/60031106"/></author><author seq="3" auid="6507603461"><ce:initials>B.</ce:initials><ce:indexed-name>Slivnik B.</ce:indexed-name><ce:surname>Slivnik</ce:surname><ce:given-name>Boštjan</ce:given-name><preferred-name><ce:initials>B.</ce:initials><ce:indexed-name>Slivnik B.</ce:indexed-name><ce:surname>Slivnik</ce:surname><ce:given-name>Boštjan</ce:given-name></preferred-name><author-url>https://api.elsevier.com/content/author/author_id/6507603461</author-url><affiliation id="60031106" href="https://api.elsevier.com/content/affiliation/affiliation_id/60031106"/></author></authors><language xml:lang="eng"/><authkeywords><author-keyword>Abstract interpretation</author-keyword><author-keyword>Scala</author-keyword><author-keyword>Static analysis</author-keyword></authkeywords><idxterms><mainterm weight="b" candidate="n">Abstract interpretations</mainterm><mainterm weight="b" candidate="n">Abstract Syntax Trees</mainterm><mainterm weight="b" candidate="n">Plug-ins</mainterm><mainterm weight="b" candidate="n">Potential problems</mainterm><mainterm weight="b" candidate="n">Scala</mainterm><mainterm weight="b" candidate="n">Source codes</mainterm><mainterm weight="b" candidate="n">Time consumption</mainterm></idxterms><subject-areas><subject-area code="1712" abbrev="COMP">Software</subject-area></subject-areas><item xmlns=""><ait:process-info><ait:date-delivered day="11" month="08" timestamp="2019-08-11T23:51:14.000014-04:00" year="2019"/><ait:date-sort day="01" month="01" year="2014"/><ait:status stage="S300" state="update" type="core"/></ait:process-info><bibrecord><item-info><copyright type="Elsevier">Copyright 2014 Elsevier B.V., All rights reserved.</copyright><itemidlist><ce:doi>10.1145/2554850.2555129</ce:doi><itemid idtype="PUI">373713568</itemid><itemid idtype="CAR-ID">422792229</itemid><itemid idtype="CPX">20143318061919</itemid><itemid idtype="SCP">84905643491</itemid><itemid idtype="SGR">84905643491</itemid></itemidlist><history><date-created day="14" month="08" year="2014"/></history><dbcollection>CPX</dbcollection><dbcollection>Scopusbase</dbcollection></item-info><head><citation-info><citation-type code="cp"/><citation-language xml:lang="eng" language="English"/><abstract-language xml:lang="eng" language="English"/><author-keywords><author-keyword xml:lang="eng">Abstract interpretation</author-keyword><author-keyword xml:lang="eng">Scala</author-keyword><author-keyword xml:lang="eng">Static analysis</author-keyword></author-keywords></citation-info><citation-title><titletext original="y" xml:lang="eng" language="English">Linter - A tool for finding bugs and potential problems in Scala code</titletext></citation-title><author-group><author auid="6602764771" seq="1" type="auth"><ce:initials>M.</ce:initials><ce:indexed-name>Potocnik M.</ce:indexed-name><ce:surname>Potocnik</ce:surname><ce:given-name>Matic</ce:given-name><preferred-name><ce:initials>M.</ce:initials><ce:indexed-name>Potocnik M.</ce:indexed-name><ce:surname>Potocnik</ce:surname><ce:given-name>Matic</ce:given-name></preferred-name></author><author auid="8911840700" seq="2" type="auth"><ce:initials>U.</ce:initials><ce:indexed-name>Cibej U.</ce:indexed-name><ce:surname>Čibej</ce:surname><ce:given-name>Uroš</ce:given-name><preferred-name><ce:initials>U.</ce:initials><ce:indexed-name>Čibej U.</ce:indexed-name><ce:surname>Čibej</ce:surname><ce:given-name>Uroš</ce:given-name></preferred-name></author><author auid="6507603461" date-locked="2018-11-14T12:18:28.908" seq="3" type="auth"><ce:initials>B.</ce:initials><ce:indexed-name>Slivnik B.</ce:indexed-name><ce:surname>Slivnik</ce:surname><ce:given-name>Boštjan</ce:given-name><preferred-name><ce:initials>B.</ce:initials><ce:indexed-name>Slivnik B.</ce:indexed-name><ce:surname>Slivnik</ce:surname><ce:given-name>Boštjan</ce:given-name></preferred-name></author><affiliation afid="60031106" country="svn"><organization>Faculty of Computer and Information Science, University of Ljubljana</organization><address-part>Tržaška ulica 25</address-part><city-group>1000 Ljubljana</city-group><affiliation-id afid="60031106"/><country>Slovenia</country></affiliation></author-group><abstracts><abstract original="y" xml:lang="eng"><ce:para>Linter is a static analysis tool for Scala. To check for possible bugs, inefficient code, and coding style problems it combines simple pattern matching used in many similar static analysis tools for other programming languages with abstract interpretation on some builtin types like integers and strings. Taking advantage of the Scala compiler plugin interface it relies on the Scala compiler (a) to parse the source code and (b) to provide the abstract syntax tree with all needed information. This paper provides an overview of Linter and its implementation. Using a case study the performance of Linter is evaluated in terms of time consumption and code issues detected. Copyright 2014 ACM.</ce:para></abstract></abstracts><source country="usa" srcid="89358" type="p"><sourcetitle>Proceedings of the ACM Symposium on Applied Computing</sourcetitle><sourcetitle-abbrev>Proc ACM Symp Appl Computing</sourcetitle-abbrev><translated-sourcetitle xml:lang="eng">Proceedings of the ACM Symposium on Applied Computing</translated-sourcetitle><issuetitle>Proceedings of the 29th Annual ACM Symposium on Applied Computing, SAC 2014</issuetitle><isbn length="13" level="volume" type="print">9781450324694</isbn><volisspag><pagerange first="1615" last="1616"/></volisspag><publicationyear first="2014"/><publicationdate><year>2014</year><date-text xfab-added="true">2014</date-text></publicationdate><publisher><publishername>Association for Computing Machinery</publishername><ce:e-address type="email">acmhelpacm.org</ce:e-address></publisher><additional-srcinfo><conferenceinfo><confevent><confname>29th Annual ACM Symposium on Applied Computing, SAC 2014</confname><conflocation country="kor"><city-group>Gyeongju</city-group></conflocation><confdate><startdate day="24" month="03" year="2014"/><enddate day="28" month="03" year="2014"/></confdate><confcode>106778</confcode><confsponsors complete="y"><confsponsor>ACM Special Interest Group on Applied Computing (SIGAPP)</confsponsor></confsponsors></confevent><confpublication><procpagerange>var.pagings</procpagerange></confpublication></conferenceinfo></additional-srcinfo></source><enhancement><classificationgroup><classifications type="CPXCLASS"><classification> <classification-code>723</classification-code> <classification-description>Computer Software, Data Handling and Applications</classification-description> </classification><classification> <classification-code>903.1</classification-code> <classification-description>Information Sources and Analysis</classification-description> </classification></classifications><classifications type="FLXCLASS"><classification> <classification-code>902</classification-code> <classification-description>FLUIDEX; Related Topics</classification-description> </classification></classifications><classifications type="ASJC"><classification>1712</classification></classifications><classifications type="SUBJABBR"><classification>COMP</classification></classifications></classificationgroup></enhancement></head><tail><bibliography refcount="5"><reference id="1"><ref-info><ref-title><ref-titletext>A few billion lines of code later: Using static analysis to find bugs in the real world</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">75749147262</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>A.</ce:initials><ce:indexed-name>Bessey A.</ce:indexed-name><ce:surname>Bessey</ce:surname></author><author seq="2"><ce:initials>K.</ce:initials><ce:indexed-name>Block K.</ce:indexed-name><ce:surname>Block</ce:surname></author><author seq="3"><ce:initials>B.</ce:initials><ce:indexed-name>Chelf B.</ce:indexed-name><ce:surname>Chelf</ce:surname></author><author seq="4"><ce:initials>A.</ce:initials><ce:indexed-name>Chou A.</ce:indexed-name><ce:surname>Chou</ce:surname></author><author seq="5"><ce:initials>B.</ce:initials><ce:indexed-name>Fulton B.</ce:indexed-name><ce:surname>Fulton</ce:surname></author><author seq="6"><ce:initials>S.</ce:initials><ce:indexed-name>Hallem S.</ce:indexed-name><ce:surname>Hallem</ce:surname></author><author seq="7"><ce:initials>C.</ce:initials><ce:indexed-name>Henri-Gros C.</ce:indexed-name><ce:surname>Henri-Gros</ce:surname></author><author seq="8"><ce:initials>A.</ce:initials><ce:indexed-name>Kamsky A.</ce:indexed-name><ce:surname>Kamsky</ce:surname></author><author seq="9"><ce:initials>S.</ce:initials><ce:indexed-name>McPeak S.</ce:indexed-name><ce:surname>McPeak</ce:surname></author><author seq="10"><ce:initials>D.</ce:initials><ce:indexed-name>Engler D.</ce:indexed-name><ce:surname>Engler</ce:surname></author></ref-authors><ref-sourcetitle>Communications of ACM</ref-sourcetitle><ref-publicationyear first="2010"/><ref-volisspag><voliss issue="2" volume="53"/><pagerange first="66" last="75"/></ref-volisspag></ref-info><ref-fulltext>A. Bessey, K. Block, B. Chelf, A. Chou, B. Fulton, S. Hallem, C. Henri-Gros, A. Kamsky, S. McPeak, and D. Engler. A few billion lines of code later: using static analysis to find bugs in the real world. Communications of ACM, 53(2):66-75, 2010.</ref-fulltext></reference><reference id="2"><ref-info><ref-title><ref-titletext>Why don't software developers use static analysis tools to find bugs?</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">84886386212</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>B.</ce:initials><ce:indexed-name>Johnson B.</ce:indexed-name><ce:surname>Johnson</ce:surname></author><author seq="2"><ce:initials>Y.</ce:initials><ce:indexed-name>Song Y.</ce:indexed-name><ce:surname>Song</ce:surname></author><author seq="3"><ce:initials>E.</ce:initials><ce:indexed-name>Murphy-Hill E.</ce:indexed-name><ce:surname>Murphy-Hill</ce:surname></author><author seq="4"><ce:initials>R.</ce:initials><ce:indexed-name>Bowdidge R.</ce:indexed-name><ce:surname>Bowdidge</ce:surname></author></ref-authors><ref-sourcetitle>Proceedings of the 2013 International Conference on Software Engineering, ICSE'13</ref-sourcetitle><ref-publicationyear first="2013"/><ref-volisspag><pagerange first="672" last="681"/></ref-volisspag><ref-text>Piscataway, NJ, USA IEEE Press</ref-text></ref-info><ref-fulltext>B. Johnson, Y. Song, E. Murphy-Hill, and R. Bowdidge. Why don't software developers use static analysis tools to find bugs? In Proceedings of the 2013 International Conference on Software Engineering, ICSE'13, pages 672-681, Piscataway, NJ, USA, 2013. IEEE Press.</ref-fulltext></reference><reference id="3"><ref-info><refd-itemidlist><itemid idtype="SGR">84905644608</itemid></refd-itemidlist><ref-sourcetitle>Linter</ref-sourcetitle><ref-publicationyear first="2013"/><ref-website><ce:e-address type="email">https://github.com/hairyfotr/linter</ce:e-address></ref-website></ref-info><ref-fulltext>Linter - https://github.com/hairyfotr/linter. 2013.</ref-fulltext></reference><reference id="4"><ref-info><ref-title><ref-titletext>FACTORIE: Probabilistic programming via imperatively defined factor graphs</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">84863338363</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>A.</ce:initials><ce:indexed-name>McCallum A.</ce:indexed-name><ce:surname>McCallum</ce:surname></author><author seq="2"><ce:initials>K.</ce:initials><ce:indexed-name>Schultz K.</ce:indexed-name><ce:surname>Schultz</ce:surname></author><author seq="3"><ce:initials>S.</ce:initials><ce:indexed-name>Singh S.</ce:indexed-name><ce:surname>Singh</ce:surname></author></ref-authors><ref-sourcetitle>Neural Information Processing Systems (NIPS)</ref-sourcetitle><ref-publicationyear first="2009"/></ref-info><ref-fulltext>A. McCallum, K. Schultz, and S. Singh. FACTORIE: Probabilistic programming via imperatively defined factor graphs. In Neural Information Processing Systems (NIPS), 2009.</ref-fulltext></reference><reference id="5"><ref-info><ref-title><ref-titletext>Securing java code: Heuristics and an evaluation of static analysis tools</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">57449101131</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>M.S.</ce:initials><ce:indexed-name>Ware M.S.</ce:indexed-name><ce:surname>Ware</ce:surname></author><author seq="2"><ce:initials>C.J.</ce:initials><ce:indexed-name>Fox C.J.</ce:indexed-name><ce:surname>Fox</ce:surname></author></ref-authors><ref-sourcetitle>Proceedings of the 2008 Workshop on Static Analysis, SAW'08</ref-sourcetitle><ref-publicationyear first="2008"/><ref-volisspag><pagerange first="12" last="21"/></ref-volisspag><ref-text>New York, NY, USA ACM</ref-text></ref-info><ref-fulltext>M. S. Ware and C. J. Fox. Securing Java code: heuristics and an evaluation of static analysis tools. In Proceedings of the 2008 workshop on Static analysis, SAW'08, pages 12-21, New York, NY, USA, 2008. ACM.</ref-fulltext></reference></bibliography></tail></bibrecord></item></abstracts-retrieval-response>