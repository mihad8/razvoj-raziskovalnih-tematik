<abstracts-retrieval-response xmlns="http://www.elsevier.com/xml/svapi/abstract/dtd" xmlns:dn="http://www.elsevier.com/xml/svapi/abstract/dtd" xmlns:ait="http://www.elsevier.com/xml/ani/ait" xmlns:ce="http://www.elsevier.com/xml/ani/common" xmlns:cto="http://www.elsevier.com/xml/cto/dtd" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/" xmlns:xocs="http://www.elsevier.com/xml/xocs/dtd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><coredata><prism:url>https://api.elsevier.com/content/abstract/scopus_id/84937415213</prism:url><dc:identifier>SCOPUS_ID:84937415213</dc:identifier><eid>2-s2.0-84937415213</eid><dc:title>Refining complete hypotheses in ilp</dc:title><prism:aggregationType>Book Series</prism:aggregationType><srctype>k</srctype><subtype>cp</subtype><subtypeDescription>Conference Paper</subtypeDescription><citedby-count>18</citedby-count><prism:publicationName>Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)</prism:publicationName><dc:publisher>Springer Verlagservice@springer.de</dc:publisher><source-id>25674</source-id><prism:isbn>3540661093</prism:isbn><prism:isbn>9783540661092</prism:isbn><prism:issn>16113349 03029743</prism:issn><prism:volume>1634</prism:volume><prism:startingPage>44</prism:startingPage><prism:endingPage>55</prism:endingPage><prism:pageRange>44-55</prism:pageRange><prism:coverDate>1999-01-01</prism:coverDate><openaccess/><openaccessFlag/><dc:creator><author seq="1" auid="7003286588"><ce:initials>I.</ce:initials><ce:indexed-name>Bratko I.</ce:indexed-name><ce:surname>Bratko</ce:surname><ce:given-name>Ivan</ce:given-name><preferred-name><ce:initials>I.</ce:initials><ce:indexed-name>Bratko I.</ce:indexed-name><ce:surname>Bratko</ce:surname><ce:given-name>Ivan</ce:given-name></preferred-name><author-url>https://api.elsevier.com/content/author/author_id/7003286588</author-url><affiliation id="60031106" href="https://api.elsevier.com/content/affiliation/affiliation_id/60031106"/></author></dc:creator><dc:description><abstract xmlns="" original="y" xml:lang="eng"><publishercopyright>© Springer-Verlag Berlin Heidelberg 1999.</publishercopyright><ce:para>Most ILP systems employ the covering algorithm whereby hypotheses are constructed iteratively clause by clause. Typically the covering algorithm is greedy in the sense that each iteration adds the best clause according to some local evaluation criterion. Some typical problems of the covering algorithm are: unnecessarily long hypotheses, difficulties in handling recursion, difficulties in learning multiple predicates. This paper investigates a non-covering approach to ILP, implemented as a Prolog program called HYPER, whose goals were: use intensional background knowledge, handle recursion well, and enable multi-predicate learning. Experimental results in this paper may appear surprising in the view of the very high combinatorial complexity of the search space associated with the non-covering approach.</ce:para></abstract></dc:description><link href="https://api.elsevier.com/content/abstract/scopus_id/84937415213" rel="self"/><link href="https://www.scopus.com/inward/record.uri?partnerID=HzOxMe3b&amp;scp=84937415213&amp;origin=inward" rel="scopus"/><link href="https://www.scopus.com/inward/citedby.uri?partnerID=HzOxMe3b&amp;scp=84937415213&amp;origin=inward" rel="scopus-citedby"/></coredata><affiliation id="60031106" href="https://api.elsevier.com/content/affiliation/affiliation_id/60031106"><affilname>University of Ljubljana</affilname><affiliation-city>Ljubljana</affiliation-city><affiliation-country>Slovenia</affiliation-country></affiliation><authors><author seq="1" auid="7003286588"><ce:initials>I.</ce:initials><ce:indexed-name>Bratko I.</ce:indexed-name><ce:surname>Bratko</ce:surname><ce:given-name>Ivan</ce:given-name><preferred-name><ce:initials>I.</ce:initials><ce:indexed-name>Bratko I.</ce:indexed-name><ce:surname>Bratko</ce:surname><ce:given-name>Ivan</ce:given-name></preferred-name><author-url>https://api.elsevier.com/content/author/author_id/7003286588</author-url><affiliation id="60031106" href="https://api.elsevier.com/content/affiliation/affiliation_id/60031106"/></author></authors><language xml:lang="eng"/><authkeywords/><idxterms><mainterm weight="b" candidate="n">A-prolog</mainterm><mainterm weight="b" candidate="n">Back-ground knowledge</mainterm><mainterm weight="b" candidate="n">Combinatorial complexity</mainterm><mainterm weight="b" candidate="n">Covering algorithms</mainterm><mainterm weight="b" candidate="n">Evaluation criteria</mainterm><mainterm weight="b" candidate="n">Multiple predicates</mainterm><mainterm weight="b" candidate="n">Recursions</mainterm><mainterm weight="b" candidate="n">Search spaces</mainterm></idxterms><subject-areas><subject-area code="2614" abbrev="MATH">Theoretical Computer Science</subject-area><subject-area code="1700" abbrev="COMP">Computer Science (all)</subject-area></subject-areas><item xmlns=""><ait:process-info><ait:date-delivered year="2019" month="08" day="18" timestamp="2019-08-18T03:45:00.000000-04:00"/><ait:date-sort year="1999" month="01" day="01"/><ait:status type="core" state="update" stage="S300"/></ait:process-info><bibrecord><item-info><copyright type="Elsevier">Copyright 2015 Elsevier B.V., All rights reserved.</copyright><itemidlist><itemid idtype="PUI">607184800</itemid><itemid idtype="CAR-ID">642896254</itemid><itemid idtype="CPX">20155001662432</itemid><itemid idtype="SCP">84937415213</itemid><itemid idtype="SGR">84937415213</itemid></itemidlist><history><date-created year="2015" month="12" day="12" timestamp="BST 12:39:16"/></history><dbcollection>CPX</dbcollection><dbcollection>Scopusbase</dbcollection></item-info><head><citation-info><citation-type code="cp"/><citation-language xml:lang="eng" language="English"/><abstract-language xml:lang="eng" language="English"/></citation-info><citation-title><titletext xml:lang="eng" original="y" language="English">Refining complete hypotheses in ilp</titletext></citation-title><author-group><author auid="7003286588" seq="1" type="auth"><ce:initials>I.</ce:initials><ce:indexed-name>Bratko I.</ce:indexed-name><ce:surname>Bratko</ce:surname><ce:given-name>Ivan</ce:given-name><preferred-name><ce:initials>I.</ce:initials><ce:indexed-name>Bratko I.</ce:indexed-name><ce:surname>Bratko</ce:surname><ce:given-name>Ivan</ce:given-name></preferred-name></author><affiliation afid="60031106" country="svn"><organization>University of Ljubljana</organization><address-part>Trzaska 25</address-part><city>Ljubljana</city><postal-code>1000</postal-code><affiliation-id afid="60031106"/><country>Slovenia</country></affiliation></author-group><correspondence><person><ce:initials>I.</ce:initials><ce:indexed-name>Bratko I.</ce:indexed-name><ce:surname>Bratko</ce:surname><ce:given-name>Ivan</ce:given-name></person><affiliation country="svn"><organization>University of Ljubljana</organization><address-part>Trzaska 25</address-part><city>Ljubljana</city><postal-code>1000</postal-code><country>Slovenia</country></affiliation></correspondence><abstracts><abstract original="y" xml:lang="eng"><publishercopyright>© Springer-Verlag Berlin Heidelberg 1999.</publishercopyright><ce:para>Most ILP systems employ the covering algorithm whereby hypotheses are constructed iteratively clause by clause. Typically the covering algorithm is greedy in the sense that each iteration adds the best clause according to some local evaluation criterion. Some typical problems of the covering algorithm are: unnecessarily long hypotheses, difficulties in handling recursion, difficulties in learning multiple predicates. This paper investigates a non-covering approach to ILP, implemented as a Prolog program called HYPER, whose goals were: use intensional background knowledge, handle recursion well, and enable multi-predicate learning. Experimental results in this paper may appear surprising in the view of the very high combinatorial complexity of the search space associated with the non-covering approach.</ce:para></abstract></abstracts><source srcid="25674" type="k" country="deu"><sourcetitle>Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)</sourcetitle><sourcetitle-abbrev>Lect. Notes Comput. Sci.</sourcetitle-abbrev><translated-sourcetitle xml:lang="eng">Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)</translated-sourcetitle><issuetitle>Inductive Logic Programming - 9th International Workshop, ILP 1999, Proceedings</issuetitle><issn type="electronic">16113349</issn><issn type="print">03029743</issn><isbn type="print" length="10" level="volume">3540661093</isbn><isbn type="print" length="13" level="volume">9783540661092</isbn><volisspag><voliss volume="1634"/><pagerange first="44" last="55"/></volisspag><publicationyear first="1999"/><publicationdate><year>1999</year><date-text xfab-added="true">1999</date-text></publicationdate><website><ce:e-address type="email">http://springerlink.com/content/0302-9743/copyright/2005/</ce:e-address></website><contributor-group><contributor role="edit" seq="1"><ce:initials>P.</ce:initials><ce:indexed-name>Flach P.</ce:indexed-name><ce:surname>Flach</ce:surname><ce:given-name>Peter</ce:given-name><ce:e-address type="email">Peter.Flach@bristol.ac.uk</ce:e-address></contributor></contributor-group><contributor-group><affiliation country="gbr"><organization>University of Bristol, Department of Computer Science</organization><address-part>Merchant Venturers Building, Woodland Road</address-part><city>Bristol</city><postal-code>BS8 1UB</postal-code></affiliation></contributor-group><contributor-group><contributor role="edit" seq="1"><ce:initials>S.</ce:initials><ce:indexed-name>Dzeroski S.</ce:indexed-name><ce:surname>Dzeroski</ce:surname><ce:given-name>Saso</ce:given-name><ce:e-address type="email">Saso.Dzeroski@ijs.si</ce:e-address></contributor></contributor-group><contributor-group><affiliation country="svn"><organization>Jožef Stefan Institute, Department of Intelligent Systems</organization><address-part>Jamova 39</address-part><city>Ljubljana</city><postal-code>SI-1000</postal-code></affiliation></contributor-group><publisher><publishername>Springer Verlag</publishername><ce:e-address type="email">service@springer.de</ce:e-address></publisher><additional-srcinfo><conferenceinfo><confevent><confname>9th International Workshop on Inductive Logic Programming, ILP 1999</confname><confnumber>9th</confnumber><confseriestitle>International Workshop on Inductive Logic Programming</confseriestitle><conflocation country="svn"><city>Bled</city></conflocation><confdate><startdate year="1999" month="06" day="24"/><enddate year="1999" month="06" day="27"/></confdate><confcode>144109</confcode><confsponsors complete="n"><confsponsor>COMPULOG Net, European Network of Excellence in Computational Logic</confsponsor><confsponsor>ILPnet2, Network of Excellence in Inductive Logic Programming</confsponsor><confsponsor>Jozef Stefan Institute, Ljubljana</confsponsor><confsponsor>LPA Software, Inc.</confsponsor><confsponsor>University of Bristol</confsponsor></confsponsors></confevent></conferenceinfo></additional-srcinfo></source><enhancement><classificationgroup><classifications type="CPXCLASS"><classification> <classification-code>723.1</classification-code> <classification-description>Computer Programming</classification-description> </classification><classification> <classification-code>723.1.1</classification-code> <classification-description>Computer Programming Languages</classification-description> </classification><classification> <classification-code>921.6</classification-code> <classification-description>Numerical Methods</classification-description> </classification></classifications><classifications type="FLXCLASS"><classification> <classification-code>902</classification-code> <classification-description>FLUIDEX; Related Topics</classification-description> </classification></classifications><classifications type="ASJC"><classification>2614</classification><classification>1700</classification></classifications><classifications type="SUBJABBR"><classification>MATH</classification><classification>COMP</classification></classifications></classificationgroup></enhancement></head><tail><bibliography refcount="5"><reference id="1"><ref-info><ref-title><ref-titletext>Inductive learning applied to program construction and verification</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">84949301045</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>I.</ce:initials><ce:indexed-name>Bratko I.</ce:indexed-name><ce:surname>Bratko</ce:surname></author><author seq="2"><ce:initials>M.</ce:initials><ce:indexed-name>Grobelnik M.</ce:indexed-name><ce:surname>Grobelnik</ce:surname></author></ref-authors><ref-sourcetitle>Proc. ILP Workshop 93</ref-sourcetitle><ref-publicationyear first="1993"/><ref-text>Bled, Slovenia</ref-text></ref-info><ref-fulltext>Bratko, I., Grobelnik, M. (1993) Inductive learning applied to program construction and verification. Proc. ILP Workshop 93, Bled, Slovenia.</ref-fulltext></reference><reference id="2"><ref-info><ref-title><ref-titletext>Markus - an optimised model inference system</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">0347477310</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>M.</ce:initials><ce:indexed-name>Grobelnik M.</ce:indexed-name><ce:surname>Grobelnik</ce:surname></author></ref-authors><ref-sourcetitle>Proc. ECAI Workshop on Logical Approaches to Machine Learning</ref-sourcetitle><ref-publicationyear first="1992"/><ref-text>Vienna</ref-text></ref-info><ref-fulltext>Grobelnik, M. (1992) Markus - an optimised model inference system. Proc. ECAI Workshop on Logical Approaches to Machine Learning, Vienna.</ref-fulltext></reference><reference id="3"><ref-info><ref-title><ref-titletext>Inverse entailment and Progol</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">77951503082</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>S.</ce:initials><ce:indexed-name>Muggleton S.</ce:indexed-name><ce:surname>Muggleton</ce:surname></author></ref-authors><ref-sourcetitle>New Generation Computing</ref-sourcetitle><ref-publicationyear first="1995"/><ref-volisspag><voliss volume="13"/><pagerange first="245" last="286"/></ref-volisspag></ref-info><ref-fulltext>Muggleton, S. (1995) Inverse entailment and Progol. New Generation Computing, 13 (1995), 245-286.</ref-fulltext></reference><reference id="4"><ref-info><refd-itemidlist><itemid idtype="SGR">84949301046</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>U.</ce:initials><ce:indexed-name>Pompe U.</ce:indexed-name><ce:surname>Pompe</ce:surname></author></ref-authors></ref-info><ref-fulltext>Pompe, U. (1998) Constraint Inductive Logic Programming. Ph.D. Thesis, University of Ljubljana, Faculty of Computer and Info. Sc. (In Slovenian).</ref-fulltext></reference><reference id="5"><ref-info><ref-title><ref-titletext>Learning logical definitions from relations</ref-titletext></ref-title><refd-itemidlist><itemid idtype="SGR">0001172265</itemid></refd-itemidlist><ref-authors><author seq="1"><ce:initials>J.R.</ce:initials><ce:indexed-name>Quinlan J.R.</ce:indexed-name><ce:surname>Quinlan</ce:surname></author></ref-authors><ref-sourcetitle>Machine Learning</ref-sourcetitle><ref-publicationyear first="1990"/><ref-volisspag><voliss volume="5"/><pagerange first="239" last="266"/></ref-volisspag></ref-info><ref-fulltext>Quinlan, J.R. (1990) Learning logical definitions from relations. Machine Learning, 5 (1990), 239-266.</ref-fulltext></reference></bibliography></tail></bibrecord></item></abstracts-retrieval-response>